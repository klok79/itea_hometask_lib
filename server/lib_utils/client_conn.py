import socket


"""
Клас, що відповідає за роботу кожного окремого клієнта. Він :
1. Створюється бібліотекою в окремому потоці при приєднанні клієнта.
2. Має відправляти клієнту головне меню, чекати вводу номеру та виконувати певні дії.
3. Можливо, всі ті методи, що були описані в самій бібліотеці - мають перекочувати в цей клас,
   а сама бібліотека має залишитися просто як диспатчек клієтів, хоча теж ні, бо перелік книг і 
   читачів - це властивості бібліотеки, а не конкретного з'єднання.
   ----------------------------------------------------------------
   Не розумію, як то має бути.
   Поки що реалізую окремий клас з'єднання клієнта, який тільки виводить головне меню. 
   Щоб два клієнти одночасно працювали
   ----------------------------------------------------------------
 
"""
class Client_conn:
    def __init__(self, conn:socket.socket, menu: dict, func_list:list, lib):
        self.conn = conn
        self.main_menu = menu
        self.lib = lib
        self.func_list = func_list

    def __call__(self, *args, **kwargs):
        """
        Метод диспетчер головного циклу. Виводить меню, очікує вводу та запускає методи пунктів меню
        Виконується в потоці, окремо для кожного з'єднання

        :return: Нічого не вертає
        """

        while True:
            value = self.lib.select_menu(conn=self.conn, title='ГОЛОВНЕ МЕНЮ БІБЛІОТЕКИ', menu=self.main_menu,
                                     question='Введіть номер дії, яку необхідно зробити: ')
            if value == self.lib.fail:
                value = '0'

            if value is not None:
                self.func_list[int(value)](self.conn)
                if value == '0':
                    self.conn.close()
                    break       # Цей брек завершить потік класа
                else:
                    self.lib.client_print(conn=self.conn, title='Натисніть Enter для продовження', input=True)
